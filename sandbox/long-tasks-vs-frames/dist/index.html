<!DOCTYPE html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>

	<div>
		<input type="button" value="Click me rapidly">
	</div>


<script>const element = document.querySelector('input[type="button"]');
// Within Rendering, the order of steps should always be:
// - Animation Frame Callback
// - Resize Observer
// - Commit
// We cannot measure Commit directly, so lets measure end of resize as a proxy.
// However, we don't always have a resize event, so, if we measure
// two animation frames in a row without resize, reset the commit timer.
// Alternatives is to use Layout Shift times, which are assigned at pre-paint
let previousFrameTime = 0;
let previousCommit = 0;
function updatesTimes({ frameTime , resizeEnd  }) {
    if (frameTime) {
        if (previousFrameTime) performance.measure("Frame2Frame", {
            start: previousFrameTime,
            end: frameTime
        });
        if (previousFrameTime > previousCommit) previousCommit = 0;
        previousFrameTime = frameTime;
    }
    if (resizeEnd) {
        const commit = resizeEnd;
        if (previousCommit) performance.measure("Commit2Commit", {
            start: previousCommit,
            end: commit
        });
        previousCommit = commit;
    }
}
function block(ms) {
    const target = performance.now() + ms;
    while(performance.now() < target);
}
function simulateLongTask() {
    block(50);
}
function resizeABit() {
    const scale = 100 + Math.floor(Math.random() * 100);
    element.style.fontSize = `${scale}%`;
}
function longClickHandler(event) {
    resizeABit();
    simulateLongTask();
    requestAnimationFrame(simulateLongTask);
}
function spamPageWithManyLongTasks() {
    // Rather than a setTimeout loop, add these all to the queue upfront
    const keepPageJankyFor = 5; // seconds
    const count = keepPageJankyFor * 1000 / 50;
    for(let i = 0; i < count; i++)setTimeout(simulateLongTask, 0);
}
function measureAnimationFrames() {
    requestAnimationFrame((frameTime)=>{
        updatesTimes({
            frameTime: performance.now()
        }); // Overwrite frametime
        measureAnimationFrames();
    });
}
function measureLongTasks() {
    new PerformanceObserver((list)=>{
        for (const entry of list.getEntries())// console.log('Long Task:', entry.startTime, entry.duration, entry);
        performance.measure("Long Task", {
            start: entry.startTime,
            duration: entry.duration
        });
    }).observe({
        type: "longtask",
        buffered: true
    });
}
function measureResizeObserver() {
    simulateLongTask();
    updatesTimes({
        resizeEnd: performance.now()
    });
}
function addSlowObservers() {
    element.addEventListener("click", longClickHandler);
    new ResizeObserver(measureResizeObserver).observe(element);
    [
        "mousemove",
        "scroll",
        "resize"
    ].forEach((type)=>document.addEventListener(type, simulateLongTask));
}
function main() {
    measureAnimationFrames();
    measureLongTasks();
    addSlowObservers();
    spamPageWithManyLongTasks();
    // queue one last task to report findings
    setTimeout(()=>{
        const longestInteraction = performance.getEntriesByType("event").filter((entry)=>!!entry.interactionId).sort((a, b)=>b.duration - a.duration)[0];
        const longestFrame = performance.getEntriesByName("Commit2Commit", "measure").sort((a, b)=>b.duration - a.duration)[0];
    }, 0);
}
main();

</script>

<script src="/long-tasks-vs-frames.3464ddca.js"></script></body>
	
